import te from "fs";
import ke from "path";
function Vr(u) {
  return u && u.__esModule && Object.prototype.hasOwnProperty.call(u, "default") ? u.default : u;
}
var Te = { exports: {} }, M = {}, re = {}, X = {}, sr;
function ne() {
  if (sr) return X;
  sr = 1;
  function u(c) {
    return typeof c > "u" || c === null;
  }
  function y(c) {
    return typeof c == "object" && c !== null;
  }
  function S(c) {
    return Array.isArray(c) ? c : u(c) ? [] : [c];
  }
  function b(c, h) {
    var n, i, t, w;
    if (h)
      for (w = Object.keys(h), n = 0, i = w.length; n < i; n += 1)
        t = w[n], c[t] = h[t];
    return c;
  }
  function v(c, h) {
    var n = "", i;
    for (i = 0; i < h; i += 1)
      n += c;
    return n;
  }
  function s(c) {
    return c === 0 && Number.NEGATIVE_INFINITY === 1 / c;
  }
  return X.isNothing = u, X.isObject = y, X.toArray = S, X.repeat = v, X.isNegativeZero = s, X.extend = b, X;
}
var Be, hr;
function ce() {
  if (hr) return Be;
  hr = 1;
  function u(y, S) {
    Error.call(this), this.name = "YAMLException", this.reason = y, this.mark = S, this.message = (this.reason || "(unknown reason)") + (this.mark ? " " + this.mark.toString() : ""), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack || "";
  }
  return u.prototype = Object.create(Error.prototype), u.prototype.constructor = u, u.prototype.toString = function(S) {
    var b = this.name + ": ";
    return b += this.reason || "(unknown reason)", !S && this.mark && (b += " " + this.mark.toString()), b;
  }, Be = u, Be;
}
var Ye, dr;
function Xr() {
  if (dr) return Ye;
  dr = 1;
  var u = ne();
  function y(S, b, v, s, c) {
    this.name = S, this.buffer = b, this.position = v, this.line = s, this.column = c;
  }
  return y.prototype.getSnippet = function(b, v) {
    var s, c, h, n, i;
    if (!this.buffer) return null;
    for (b = b || 4, v = v || 75, s = "", c = this.position; c > 0 && `\0\r
\u2028\u2029`.indexOf(this.buffer.charAt(c - 1)) === -1; )
      if (c -= 1, this.position - c > v / 2 - 1) {
        s = " ... ", c += 5;
        break;
      }
    for (h = "", n = this.position; n < this.buffer.length && `\0\r
\u2028\u2029`.indexOf(this.buffer.charAt(n)) === -1; )
      if (n += 1, n - this.position > v / 2 - 1) {
        h = " ... ", n -= 5;
        break;
      }
    return i = this.buffer.slice(c, n), u.repeat(" ", b) + s + i + h + `
` + u.repeat(" ", b + this.position - c + s.length) + "^";
  }, y.prototype.toString = function(b) {
    var v, s = "";
    return this.name && (s += 'in "' + this.name + '" '), s += "at line " + (this.line + 1) + ", column " + (this.column + 1), b || (v = this.getSnippet(), v && (s += `:
` + v)), s;
  }, Ye = y, Ye;
}
var Pe, mr;
function q() {
  if (mr) return Pe;
  mr = 1;
  var u = ce(), y = [
    "kind",
    "resolve",
    "construct",
    "instanceOf",
    "predicate",
    "represent",
    "defaultStyle",
    "styleAliases"
  ], S = [
    "scalar",
    "sequence",
    "mapping"
  ];
  function b(s) {
    var c = {};
    return s !== null && Object.keys(s).forEach(function(h) {
      s[h].forEach(function(n) {
        c[String(n)] = h;
      });
    }), c;
  }
  function v(s, c) {
    if (c = c || {}, Object.keys(c).forEach(function(h) {
      if (y.indexOf(h) === -1)
        throw new u('Unknown option "' + h + '" is met in definition of "' + s + '" YAML type.');
    }), this.tag = s, this.kind = c.kind || null, this.resolve = c.resolve || function() {
      return !0;
    }, this.construct = c.construct || function(h) {
      return h;
    }, this.instanceOf = c.instanceOf || null, this.predicate = c.predicate || null, this.represent = c.represent || null, this.defaultStyle = c.defaultStyle || null, this.styleAliases = b(c.styleAliases || null), S.indexOf(this.kind) === -1)
      throw new u('Unknown kind "' + this.kind + '" is specified for "' + s + '" YAML type.');
  }
  return Pe = v, Pe;
}
var je, xr;
function ie() {
  if (xr) return je;
  xr = 1;
  var u = ne(), y = ce(), S = q();
  function b(c, h, n) {
    var i = [];
    return c.include.forEach(function(t) {
      n = b(t, h, n);
    }), c[h].forEach(function(t) {
      n.forEach(function(w, F) {
        w.tag === t.tag && w.kind === t.kind && i.push(F);
      }), n.push(t);
    }), n.filter(function(t, w) {
      return i.indexOf(w) === -1;
    });
  }
  function v() {
    var c = {
      scalar: {},
      sequence: {},
      mapping: {},
      fallback: {}
    }, h, n;
    function i(t) {
      c[t.kind][t.tag] = c.fallback[t.tag] = t;
    }
    for (h = 0, n = arguments.length; h < n; h += 1)
      arguments[h].forEach(i);
    return c;
  }
  function s(c) {
    this.include = c.include || [], this.implicit = c.implicit || [], this.explicit = c.explicit || [], this.implicit.forEach(function(h) {
      if (h.loadKind && h.loadKind !== "scalar")
        throw new y("There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.");
    }), this.compiledImplicit = b(this, "implicit", []), this.compiledExplicit = b(this, "explicit", []), this.compiledTypeMap = v(this.compiledImplicit, this.compiledExplicit);
  }
  return s.DEFAULT = null, s.create = function() {
    var h, n;
    switch (arguments.length) {
      case 1:
        h = s.DEFAULT, n = arguments[0];
        break;
      case 2:
        h = arguments[0], n = arguments[1];
        break;
      default:
        throw new y("Wrong number of arguments for Schema.create function");
    }
    if (h = u.toArray(h), n = u.toArray(n), !h.every(function(i) {
      return i instanceof s;
    }))
      throw new y("Specified list of super schemas (or a single Schema object) contains a non-Schema object.");
    if (!n.every(function(i) {
      return i instanceof S;
    }))
      throw new y("Specified list of YAML types (or a single Type object) contains a non-Type object.");
    return new s({
      include: h,
      explicit: n
    });
  }, je = s, je;
}
var He, vr;
function Zr() {
  if (vr) return He;
  vr = 1;
  var u = q();
  return He = new u("tag:yaml.org,2002:str", {
    kind: "scalar",
    construct: function(y) {
      return y !== null ? y : "";
    }
  }), He;
}
var Ue, gr;
function zr() {
  if (gr) return Ue;
  gr = 1;
  var u = q();
  return Ue = new u("tag:yaml.org,2002:seq", {
    kind: "sequence",
    construct: function(y) {
      return y !== null ? y : [];
    }
  }), Ue;
}
var Ke, Ar;
function en() {
  if (Ar) return Ke;
  Ar = 1;
  var u = q();
  return Ke = new u("tag:yaml.org,2002:map", {
    kind: "mapping",
    construct: function(y) {
      return y !== null ? y : {};
    }
  }), Ke;
}
var Ge, yr;
function pr() {
  if (yr) return Ge;
  yr = 1;
  var u = ie();
  return Ge = new u({
    explicit: [
      Zr(),
      zr(),
      en()
    ]
  }), Ge;
}
var We, Cr;
function rn() {
  if (Cr) return We;
  Cr = 1;
  var u = q();
  function y(v) {
    if (v === null) return !0;
    var s = v.length;
    return s === 1 && v === "~" || s === 4 && (v === "null" || v === "Null" || v === "NULL");
  }
  function S() {
    return null;
  }
  function b(v) {
    return v === null;
  }
  return We = new u("tag:yaml.org,2002:null", {
    kind: "scalar",
    resolve: y,
    construct: S,
    predicate: b,
    represent: {
      canonical: function() {
        return "~";
      },
      lowercase: function() {
        return "null";
      },
      uppercase: function() {
        return "NULL";
      },
      camelcase: function() {
        return "Null";
      }
    },
    defaultStyle: "lowercase"
  }), We;
}
var $e, Er;
function nn() {
  if (Er) return $e;
  Er = 1;
  var u = q();
  function y(v) {
    if (v === null) return !1;
    var s = v.length;
    return s === 4 && (v === "true" || v === "True" || v === "TRUE") || s === 5 && (v === "false" || v === "False" || v === "FALSE");
  }
  function S(v) {
    return v === "true" || v === "True" || v === "TRUE";
  }
  function b(v) {
    return Object.prototype.toString.call(v) === "[object Boolean]";
  }
  return $e = new u("tag:yaml.org,2002:bool", {
    kind: "scalar",
    resolve: y,
    construct: S,
    predicate: b,
    represent: {
      lowercase: function(v) {
        return v ? "true" : "false";
      },
      uppercase: function(v) {
        return v ? "TRUE" : "FALSE";
      },
      camelcase: function(v) {
        return v ? "True" : "False";
      }
    },
    defaultStyle: "lowercase"
  }), $e;
}
var Je, wr;
function on() {
  if (wr) return Je;
  wr = 1;
  var u = ne(), y = q();
  function S(n) {
    return 48 <= n && n <= 57 || 65 <= n && n <= 70 || 97 <= n && n <= 102;
  }
  function b(n) {
    return 48 <= n && n <= 55;
  }
  function v(n) {
    return 48 <= n && n <= 57;
  }
  function s(n) {
    if (n === null) return !1;
    var i = n.length, t = 0, w = !1, F;
    if (!i) return !1;
    if (F = n[t], (F === "-" || F === "+") && (F = n[++t]), F === "0") {
      if (t + 1 === i) return !0;
      if (F = n[++t], F === "b") {
        for (t++; t < i; t++)
          if (F = n[t], F !== "_") {
            if (F !== "0" && F !== "1") return !1;
            w = !0;
          }
        return w && F !== "_";
      }
      if (F === "x") {
        for (t++; t < i; t++)
          if (F = n[t], F !== "_") {
            if (!S(n.charCodeAt(t))) return !1;
            w = !0;
          }
        return w && F !== "_";
      }
      for (; t < i; t++)
        if (F = n[t], F !== "_") {
          if (!b(n.charCodeAt(t))) return !1;
          w = !0;
        }
      return w && F !== "_";
    }
    if (F === "_") return !1;
    for (; t < i; t++)
      if (F = n[t], F !== "_") {
        if (F === ":") break;
        if (!v(n.charCodeAt(t)))
          return !1;
        w = !0;
      }
    return !w || F === "_" ? !1 : F !== ":" ? !0 : /^(:[0-5]?[0-9])+$/.test(n.slice(t));
  }
  function c(n) {
    var i = n, t = 1, w, F, I = [];
    return i.indexOf("_") !== -1 && (i = i.replace(/_/g, "")), w = i[0], (w === "-" || w === "+") && (w === "-" && (t = -1), i = i.slice(1), w = i[0]), i === "0" ? 0 : w === "0" ? i[1] === "b" ? t * parseInt(i.slice(2), 2) : i[1] === "x" ? t * parseInt(i, 16) : t * parseInt(i, 8) : i.indexOf(":") !== -1 ? (i.split(":").forEach(function(k) {
      I.unshift(parseInt(k, 10));
    }), i = 0, F = 1, I.forEach(function(k) {
      i += k * F, F *= 60;
    }), t * i) : t * parseInt(i, 10);
  }
  function h(n) {
    return Object.prototype.toString.call(n) === "[object Number]" && n % 1 === 0 && !u.isNegativeZero(n);
  }
  return Je = new y("tag:yaml.org,2002:int", {
    kind: "scalar",
    resolve: s,
    construct: c,
    predicate: h,
    represent: {
      binary: function(n) {
        return n >= 0 ? "0b" + n.toString(2) : "-0b" + n.toString(2).slice(1);
      },
      octal: function(n) {
        return n >= 0 ? "0" + n.toString(8) : "-0" + n.toString(8).slice(1);
      },
      decimal: function(n) {
        return n.toString(10);
      },
      /* eslint-disable max-len */
      hexadecimal: function(n) {
        return n >= 0 ? "0x" + n.toString(16).toUpperCase() : "-0x" + n.toString(16).toUpperCase().slice(1);
      }
    },
    defaultStyle: "decimal",
    styleAliases: {
      binary: [2, "bin"],
      octal: [8, "oct"],
      decimal: [10, "dec"],
      hexadecimal: [16, "hex"]
    }
  }), Je;
}
var Qe, Fr;
function ln() {
  if (Fr) return Qe;
  Fr = 1;
  var u = ne(), y = q(), S = new RegExp(
    // 2.5e4, 2.5 and integers
    "^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*|[-+]?\\.(?:inf|Inf|INF)|\\.(?:nan|NaN|NAN))$"
  );
  function b(n) {
    return !(n === null || !S.test(n) || // Quick hack to not allow integers end with `_`
    // Probably should update regexp & check speed
    n[n.length - 1] === "_");
  }
  function v(n) {
    var i, t, w, F;
    return i = n.replace(/_/g, "").toLowerCase(), t = i[0] === "-" ? -1 : 1, F = [], "+-".indexOf(i[0]) >= 0 && (i = i.slice(1)), i === ".inf" ? t === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY : i === ".nan" ? NaN : i.indexOf(":") >= 0 ? (i.split(":").forEach(function(I) {
      F.unshift(parseFloat(I, 10));
    }), i = 0, w = 1, F.forEach(function(I) {
      i += I * w, w *= 60;
    }), t * i) : t * parseFloat(i, 10);
  }
  var s = /^[-+]?[0-9]+e/;
  function c(n, i) {
    var t;
    if (isNaN(n))
      switch (i) {
        case "lowercase":
          return ".nan";
        case "uppercase":
          return ".NAN";
        case "camelcase":
          return ".NaN";
      }
    else if (Number.POSITIVE_INFINITY === n)
      switch (i) {
        case "lowercase":
          return ".inf";
        case "uppercase":
          return ".INF";
        case "camelcase":
          return ".Inf";
      }
    else if (Number.NEGATIVE_INFINITY === n)
      switch (i) {
        case "lowercase":
          return "-.inf";
        case "uppercase":
          return "-.INF";
        case "camelcase":
          return "-.Inf";
      }
    else if (u.isNegativeZero(n))
      return "-0.0";
    return t = n.toString(10), s.test(t) ? t.replace("e", ".e") : t;
  }
  function h(n) {
    return Object.prototype.toString.call(n) === "[object Number]" && (n % 1 !== 0 || u.isNegativeZero(n));
  }
  return Qe = new y("tag:yaml.org,2002:float", {
    kind: "scalar",
    resolve: b,
    construct: v,
    predicate: h,
    represent: c,
    defaultStyle: "lowercase"
  }), Qe;
}
var Ve, _r;
function Gr() {
  if (_r) return Ve;
  _r = 1;
  var u = ie();
  return Ve = new u({
    include: [
      pr()
    ],
    implicit: [
      rn(),
      nn(),
      on(),
      ln()
    ]
  }), Ve;
}
var Xe, Sr;
function Wr() {
  if (Sr) return Xe;
  Sr = 1;
  var u = ie();
  return Xe = new u({
    include: [
      Gr()
    ]
  }), Xe;
}
var Ze, br;
function un() {
  if (br) return Ze;
  br = 1;
  var u = q(), y = new RegExp(
    "^([0-9][0-9][0-9][0-9])-([0-9][0-9])-([0-9][0-9])$"
  ), S = new RegExp(
    "^([0-9][0-9][0-9][0-9])-([0-9][0-9]?)-([0-9][0-9]?)(?:[Tt]|[ \\t]+)([0-9][0-9]?):([0-9][0-9]):([0-9][0-9])(?:\\.([0-9]*))?(?:[ \\t]*(Z|([-+])([0-9][0-9]?)(?::([0-9][0-9]))?))?$"
  );
  function b(c) {
    return c === null ? !1 : y.exec(c) !== null || S.exec(c) !== null;
  }
  function v(c) {
    var h, n, i, t, w, F, I, k = 0, L = null, G, J, W;
    if (h = y.exec(c), h === null && (h = S.exec(c)), h === null) throw new Error("Date resolve error");
    if (n = +h[1], i = +h[2] - 1, t = +h[3], !h[4])
      return new Date(Date.UTC(n, i, t));
    if (w = +h[4], F = +h[5], I = +h[6], h[7]) {
      for (k = h[7].slice(0, 3); k.length < 3; )
        k += "0";
      k = +k;
    }
    return h[9] && (G = +h[10], J = +(h[11] || 0), L = (G * 60 + J) * 6e4, h[9] === "-" && (L = -L)), W = new Date(Date.UTC(n, i, t, w, F, I, k)), L && W.setTime(W.getTime() - L), W;
  }
  function s(c) {
    return c.toISOString();
  }
  return Ze = new u("tag:yaml.org,2002:timestamp", {
    kind: "scalar",
    resolve: b,
    construct: v,
    instanceOf: Date,
    represent: s
  }), Ze;
}
var ze, Tr;
function tn() {
  if (Tr) return ze;
  Tr = 1;
  var u = q();
  function y(S) {
    return S === "<<" || S === null;
  }
  return ze = new u("tag:yaml.org,2002:merge", {
    kind: "scalar",
    resolve: y
  }), ze;
}
function $r(u) {
  throw new Error('Could not dynamically require "' + u + '". Please configure the dynamicRequireTargets or/and ignoreDynamicRequires option of @rollup/plugin-commonjs appropriately for this require call to work.');
}
var er, Or;
function fn() {
  if (Or) return er;
  Or = 1;
  var u;
  try {
    var y = $r;
    u = y("buffer").Buffer;
  } catch {
  }
  var S = q(), b = `ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=
\r`;
  function v(n) {
    if (n === null) return !1;
    var i, t, w = 0, F = n.length, I = b;
    for (t = 0; t < F; t++)
      if (i = I.indexOf(n.charAt(t)), !(i > 64)) {
        if (i < 0) return !1;
        w += 6;
      }
    return w % 8 === 0;
  }
  function s(n) {
    var i, t, w = n.replace(/[\r\n=]/g, ""), F = w.length, I = b, k = 0, L = [];
    for (i = 0; i < F; i++)
      i % 4 === 0 && i && (L.push(k >> 16 & 255), L.push(k >> 8 & 255), L.push(k & 255)), k = k << 6 | I.indexOf(w.charAt(i));
    return t = F % 4 * 6, t === 0 ? (L.push(k >> 16 & 255), L.push(k >> 8 & 255), L.push(k & 255)) : t === 18 ? (L.push(k >> 10 & 255), L.push(k >> 2 & 255)) : t === 12 && L.push(k >> 4 & 255), u ? u.from ? u.from(L) : new u(L) : L;
  }
  function c(n) {
    var i = "", t = 0, w, F, I = n.length, k = b;
    for (w = 0; w < I; w++)
      w % 3 === 0 && w && (i += k[t >> 18 & 63], i += k[t >> 12 & 63], i += k[t >> 6 & 63], i += k[t & 63]), t = (t << 8) + n[w];
    return F = I % 3, F === 0 ? (i += k[t >> 18 & 63], i += k[t >> 12 & 63], i += k[t >> 6 & 63], i += k[t & 63]) : F === 2 ? (i += k[t >> 10 & 63], i += k[t >> 4 & 63], i += k[t << 2 & 63], i += k[64]) : F === 1 && (i += k[t >> 2 & 63], i += k[t << 4 & 63], i += k[64], i += k[64]), i;
  }
  function h(n) {
    return u && u.isBuffer(n);
  }
  return er = new S("tag:yaml.org,2002:binary", {
    kind: "scalar",
    resolve: v,
    construct: s,
    predicate: h,
    represent: c
  }), er;
}
var rr, kr;
function cn() {
  if (kr) return rr;
  kr = 1;
  var u = q(), y = Object.prototype.hasOwnProperty, S = Object.prototype.toString;
  function b(s) {
    if (s === null) return !0;
    var c = [], h, n, i, t, w, F = s;
    for (h = 0, n = F.length; h < n; h += 1) {
      if (i = F[h], w = !1, S.call(i) !== "[object Object]") return !1;
      for (t in i)
        if (y.call(i, t))
          if (!w) w = !0;
          else return !1;
      if (!w) return !1;
      if (c.indexOf(t) === -1) c.push(t);
      else return !1;
    }
    return !0;
  }
  function v(s) {
    return s !== null ? s : [];
  }
  return rr = new u("tag:yaml.org,2002:omap", {
    kind: "sequence",
    resolve: b,
    construct: v
  }), rr;
}
var nr, Rr;
function an() {
  if (Rr) return nr;
  Rr = 1;
  var u = q(), y = Object.prototype.toString;
  function S(v) {
    if (v === null) return !0;
    var s, c, h, n, i, t = v;
    for (i = new Array(t.length), s = 0, c = t.length; s < c; s += 1) {
      if (h = t[s], y.call(h) !== "[object Object]" || (n = Object.keys(h), n.length !== 1)) return !1;
      i[s] = [n[0], h[n[0]]];
    }
    return !0;
  }
  function b(v) {
    if (v === null) return [];
    var s, c, h, n, i, t = v;
    for (i = new Array(t.length), s = 0, c = t.length; s < c; s += 1)
      h = t[s], n = Object.keys(h), i[s] = [n[0], h[n[0]]];
    return i;
  }
  return nr = new u("tag:yaml.org,2002:pairs", {
    kind: "sequence",
    resolve: S,
    construct: b
  }), nr;
}
var ir, Ir;
function pn() {
  if (Ir) return ir;
  Ir = 1;
  var u = q(), y = Object.prototype.hasOwnProperty;
  function S(v) {
    if (v === null) return !0;
    var s, c = v;
    for (s in c)
      if (y.call(c, s) && c[s] !== null)
        return !1;
    return !0;
  }
  function b(v) {
    return v !== null ? v : {};
  }
  return ir = new u("tag:yaml.org,2002:set", {
    kind: "mapping",
    resolve: S,
    construct: b
  }), ir;
}
var or, Lr;
function fe() {
  if (Lr) return or;
  Lr = 1;
  var u = ie();
  return or = new u({
    include: [
      Wr()
    ],
    implicit: [
      un(),
      tn()
    ],
    explicit: [
      fn(),
      cn(),
      an(),
      pn()
    ]
  }), or;
}
var lr, Dr;
function sn() {
  if (Dr) return lr;
  Dr = 1;
  var u = q();
  function y() {
    return !0;
  }
  function S() {
  }
  function b() {
    return "";
  }
  function v(s) {
    return typeof s > "u";
  }
  return lr = new u("tag:yaml.org,2002:js/undefined", {
    kind: "scalar",
    resolve: y,
    construct: S,
    predicate: v,
    represent: b
  }), lr;
}
var ur, Mr;
function hn() {
  if (Mr) return ur;
  Mr = 1;
  var u = q();
  function y(s) {
    if (s === null || s.length === 0) return !1;
    var c = s, h = /\/([gim]*)$/.exec(s), n = "";
    return !(c[0] === "/" && (h && (n = h[1]), n.length > 3 || c[c.length - n.length - 1] !== "/"));
  }
  function S(s) {
    var c = s, h = /\/([gim]*)$/.exec(s), n = "";
    return c[0] === "/" && (h && (n = h[1]), c = c.slice(1, c.length - n.length - 1)), new RegExp(c, n);
  }
  function b(s) {
    var c = "/" + s.source + "/";
    return s.global && (c += "g"), s.multiline && (c += "m"), s.ignoreCase && (c += "i"), c;
  }
  function v(s) {
    return Object.prototype.toString.call(s) === "[object RegExp]";
  }
  return ur = new u("tag:yaml.org,2002:js/regexp", {
    kind: "scalar",
    resolve: y,
    construct: S,
    predicate: v,
    represent: b
  }), ur;
}
var tr, Nr;
function dn() {
  if (Nr) return tr;
  Nr = 1;
  var u;
  try {
    var y = $r;
    u = y("esprima");
  } catch {
    typeof window < "u" && (u = window.esprima);
  }
  var S = q();
  function b(h) {
    if (h === null) return !1;
    try {
      var n = "(" + h + ")", i = u.parse(n, { range: !0 });
      return !(i.type !== "Program" || i.body.length !== 1 || i.body[0].type !== "ExpressionStatement" || i.body[0].expression.type !== "ArrowFunctionExpression" && i.body[0].expression.type !== "FunctionExpression");
    } catch {
      return !1;
    }
  }
  function v(h) {
    var n = "(" + h + ")", i = u.parse(n, { range: !0 }), t = [], w;
    if (i.type !== "Program" || i.body.length !== 1 || i.body[0].type !== "ExpressionStatement" || i.body[0].expression.type !== "ArrowFunctionExpression" && i.body[0].expression.type !== "FunctionExpression")
      throw new Error("Failed to resolve function");
    return i.body[0].expression.params.forEach(function(F) {
      t.push(F.name);
    }), w = i.body[0].expression.body.range, i.body[0].expression.body.type === "BlockStatement" ? new Function(t, n.slice(w[0] + 1, w[1] - 1)) : new Function(t, "return " + n.slice(w[0], w[1]));
  }
  function s(h) {
    return h.toString();
  }
  function c(h) {
    return Object.prototype.toString.call(h) === "[object Function]";
  }
  return tr = new S("tag:yaml.org,2002:js/function", {
    kind: "scalar",
    resolve: b,
    construct: v,
    predicate: c,
    represent: s
  }), tr;
}
var fr, qr;
function Re() {
  if (qr) return fr;
  qr = 1;
  var u = ie();
  return fr = u.DEFAULT = new u({
    include: [
      fe()
    ],
    explicit: [
      sn(),
      hn(),
      dn()
    ]
  }), fr;
}
var Br;
function mn() {
  if (Br) return re;
  Br = 1;
  var u = ne(), y = ce(), S = Xr(), b = fe(), v = Re(), s = Object.prototype.hasOwnProperty, c = 1, h = 2, n = 3, i = 4, t = 1, w = 2, F = 3, I = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/, k = /[\x85\u2028\u2029]/, L = /[,\[\]\{\}]/, G = /^(?:!|!!|![a-z\-]+!)$/i, J = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;
  function W(e) {
    return Object.prototype.toString.call(e);
  }
  function P(e) {
    return e === 10 || e === 13;
  }
  function $(e) {
    return e === 9 || e === 32;
  }
  function B(e) {
    return e === 9 || e === 32 || e === 10 || e === 13;
  }
  function Q(e) {
    return e === 44 || e === 91 || e === 93 || e === 123 || e === 125;
  }
  function Ie(e) {
    var o;
    return 48 <= e && e <= 57 ? e - 48 : (o = e | 32, 97 <= o && o <= 102 ? o - 97 + 10 : -1);
  }
  function ae(e) {
    return e === 120 ? 2 : e === 117 ? 4 : e === 85 ? 8 : 0;
  }
  function pe(e) {
    return 48 <= e && e <= 57 ? e - 48 : -1;
  }
  function se(e) {
    return e === 48 ? "\0" : e === 97 ? "\x07" : e === 98 ? "\b" : e === 116 || e === 9 ? "	" : e === 110 ? `
` : e === 118 ? "\v" : e === 102 ? "\f" : e === 114 ? "\r" : e === 101 ? "\x1B" : e === 32 ? " " : e === 34 ? '"' : e === 47 ? "/" : e === 92 ? "\\" : e === 78 ? "" : e === 95 ? " " : e === 76 ? "\u2028" : e === 80 ? "\u2029" : "";
  }
  function he(e) {
    return e <= 65535 ? String.fromCharCode(e) : String.fromCharCode(
      (e - 65536 >> 10) + 55296,
      (e - 65536 & 1023) + 56320
    );
  }
  for (var de = new Array(256), oe = new Array(256), D = 0; D < 256; D++)
    de[D] = se(D) ? 1 : 0, oe[D] = se(D);
  function Le(e, o) {
    this.input = e, this.filename = o.filename || null, this.schema = o.schema || v, this.onWarning = o.onWarning || null, this.legacy = o.legacy || !1, this.json = o.json || !1, this.listener = o.listener || null, this.implicitTypes = this.schema.compiledImplicit, this.typeMap = this.schema.compiledTypeMap, this.length = e.length, this.position = 0, this.line = 0, this.lineStart = 0, this.lineIndent = 0, this.documents = [];
  }
  function me(e, o) {
    return new y(
      o,
      new S(e.filename, e.input, e.position, e.line, e.position - e.lineStart)
    );
  }
  function T(e, o) {
    throw me(e, o);
  }
  function ee(e, o) {
    e.onWarning && e.onWarning.call(null, me(e, o));
  }
  var le = {
    YAML: function(o, p, C) {
      var d, E, r;
      o.version !== null && T(o, "duplication of %YAML directive"), C.length !== 1 && T(o, "YAML directive accepts exactly one argument"), d = /^([0-9]+)\.([0-9]+)$/.exec(C[0]), d === null && T(o, "ill-formed argument of the YAML directive"), E = parseInt(d[1], 10), r = parseInt(d[2], 10), E !== 1 && T(o, "unacceptable YAML version of the document"), o.version = C[0], o.checkLineBreaks = r < 2, r !== 1 && r !== 2 && ee(o, "unsupported YAML version of the document");
    },
    TAG: function(o, p, C) {
      var d, E;
      C.length !== 2 && T(o, "TAG directive accepts exactly two arguments"), d = C[0], E = C[1], G.test(d) || T(o, "ill-formed tag handle (first argument) of the TAG directive"), s.call(o.tagMap, d) && T(o, 'there is a previously declared suffix for "' + d + '" tag handle'), J.test(E) || T(o, "ill-formed tag prefix (second argument) of the TAG directive"), o.tagMap[d] = E;
    }
  };
  function j(e, o, p, C) {
    var d, E, r, l;
    if (o < p) {
      if (l = e.input.slice(o, p), C)
        for (d = 0, E = l.length; d < E; d += 1)
          r = l.charCodeAt(d), r === 9 || 32 <= r && r <= 1114111 || T(e, "expected valid JSON character");
      else I.test(l) && T(e, "the stream contains non-printable characters");
      e.result += l;
    }
  }
  function xe(e, o, p, C) {
    var d, E, r, l;
    for (u.isObject(p) || T(e, "cannot merge mappings; the provided source object is unacceptable"), d = Object.keys(p), r = 0, l = d.length; r < l; r += 1)
      E = d[r], s.call(o, E) || (o[E] = p[E], C[E] = !0);
  }
  function H(e, o, p, C, d, E, r, l) {
    var f, g;
    if (Array.isArray(d))
      for (d = Array.prototype.slice.call(d), f = 0, g = d.length; f < g; f += 1)
        Array.isArray(d[f]) && T(e, "nested arrays are not supported inside keys"), typeof d == "object" && W(d[f]) === "[object Object]" && (d[f] = "[object Object]");
    if (typeof d == "object" && W(d) === "[object Object]" && (d = "[object Object]"), d = String(d), o === null && (o = {}), C === "tag:yaml.org,2002:merge")
      if (Array.isArray(E))
        for (f = 0, g = E.length; f < g; f += 1)
          xe(e, o, E[f], p);
      else
        xe(e, o, E, p);
    else
      !e.json && !s.call(p, d) && s.call(o, d) && (e.line = r || e.line, e.position = l || e.position, T(e, "duplicated mapping key")), o[d] = E, delete p[d];
    return o;
  }
  function U(e) {
    var o;
    o = e.input.charCodeAt(e.position), o === 10 ? e.position++ : o === 13 ? (e.position++, e.input.charCodeAt(e.position) === 10 && e.position++) : T(e, "a line break is expected"), e.line += 1, e.lineStart = e.position;
  }
  function N(e, o, p) {
    for (var C = 0, d = e.input.charCodeAt(e.position); d !== 0; ) {
      for (; $(d); )
        d = e.input.charCodeAt(++e.position);
      if (o && d === 35)
        do
          d = e.input.charCodeAt(++e.position);
        while (d !== 10 && d !== 13 && d !== 0);
      if (P(d))
        for (U(e), d = e.input.charCodeAt(e.position), C++, e.lineIndent = 0; d === 32; )
          e.lineIndent++, d = e.input.charCodeAt(++e.position);
      else
        break;
    }
    return p !== -1 && C !== 0 && e.lineIndent < p && ee(e, "deficient indentation"), C;
  }
  function Z(e) {
    var o = e.position, p;
    return p = e.input.charCodeAt(o), !!((p === 45 || p === 46) && p === e.input.charCodeAt(o + 1) && p === e.input.charCodeAt(o + 2) && (o += 3, p = e.input.charCodeAt(o), p === 0 || B(p)));
  }
  function ue(e, o) {
    o === 1 ? e.result += " " : o > 1 && (e.result += u.repeat(`
`, o - 1));
  }
  function ve(e, o, p) {
    var C, d, E, r, l, f, g, x, a = e.kind, A = e.result, m;
    if (m = e.input.charCodeAt(e.position), B(m) || Q(m) || m === 35 || m === 38 || m === 42 || m === 33 || m === 124 || m === 62 || m === 39 || m === 34 || m === 37 || m === 64 || m === 96 || (m === 63 || m === 45) && (d = e.input.charCodeAt(e.position + 1), B(d) || p && Q(d)))
      return !1;
    for (e.kind = "scalar", e.result = "", E = r = e.position, l = !1; m !== 0; ) {
      if (m === 58) {
        if (d = e.input.charCodeAt(e.position + 1), B(d) || p && Q(d))
          break;
      } else if (m === 35) {
        if (C = e.input.charCodeAt(e.position - 1), B(C))
          break;
      } else {
        if (e.position === e.lineStart && Z(e) || p && Q(m))
          break;
        if (P(m))
          if (f = e.line, g = e.lineStart, x = e.lineIndent, N(e, !1, -1), e.lineIndent >= o) {
            l = !0, m = e.input.charCodeAt(e.position);
            continue;
          } else {
            e.position = r, e.line = f, e.lineStart = g, e.lineIndent = x;
            break;
          }
      }
      l && (j(e, E, r, !1), ue(e, e.line - f), E = r = e.position, l = !1), $(m) || (r = e.position + 1), m = e.input.charCodeAt(++e.position);
    }
    return j(e, E, r, !1), e.result ? !0 : (e.kind = a, e.result = A, !1);
  }
  function ge(e, o) {
    var p, C, d;
    if (p = e.input.charCodeAt(e.position), p !== 39)
      return !1;
    for (e.kind = "scalar", e.result = "", e.position++, C = d = e.position; (p = e.input.charCodeAt(e.position)) !== 0; )
      if (p === 39)
        if (j(e, C, e.position, !0), p = e.input.charCodeAt(++e.position), p === 39)
          C = e.position, e.position++, d = e.position;
        else
          return !0;
      else P(p) ? (j(e, C, d, !0), ue(e, N(e, !1, o)), C = d = e.position) : e.position === e.lineStart && Z(e) ? T(e, "unexpected end of the document within a single quoted scalar") : (e.position++, d = e.position);
    T(e, "unexpected end of the stream within a single quoted scalar");
  }
  function Ae(e, o) {
    var p, C, d, E, r, l;
    if (l = e.input.charCodeAt(e.position), l !== 34)
      return !1;
    for (e.kind = "scalar", e.result = "", e.position++, p = C = e.position; (l = e.input.charCodeAt(e.position)) !== 0; ) {
      if (l === 34)
        return j(e, p, e.position, !0), e.position++, !0;
      if (l === 92) {
        if (j(e, p, e.position, !0), l = e.input.charCodeAt(++e.position), P(l))
          N(e, !1, o);
        else if (l < 256 && de[l])
          e.result += oe[l], e.position++;
        else if ((r = ae(l)) > 0) {
          for (d = r, E = 0; d > 0; d--)
            l = e.input.charCodeAt(++e.position), (r = Ie(l)) >= 0 ? E = (E << 4) + r : T(e, "expected hexadecimal character");
          e.result += he(E), e.position++;
        } else
          T(e, "unknown escape sequence");
        p = C = e.position;
      } else P(l) ? (j(e, p, C, !0), ue(e, N(e, !1, o)), p = C = e.position) : e.position === e.lineStart && Z(e) ? T(e, "unexpected end of the document within a double quoted scalar") : (e.position++, C = e.position);
    }
    T(e, "unexpected end of the stream within a double quoted scalar");
  }
  function ye(e, o) {
    var p = !0, C, d = e.tag, E, r = e.anchor, l, f, g, x, a, A = {}, m, _, R, O;
    if (O = e.input.charCodeAt(e.position), O === 91)
      f = 93, a = !1, E = [];
    else if (O === 123)
      f = 125, a = !0, E = {};
    else
      return !1;
    for (e.anchor !== null && (e.anchorMap[e.anchor] = E), O = e.input.charCodeAt(++e.position); O !== 0; ) {
      if (N(e, !0, o), O = e.input.charCodeAt(e.position), O === f)
        return e.position++, e.tag = d, e.anchor = r, e.kind = a ? "mapping" : "sequence", e.result = E, !0;
      p || T(e, "missed comma between flow collection entries"), _ = m = R = null, g = x = !1, O === 63 && (l = e.input.charCodeAt(e.position + 1), B(l) && (g = x = !0, e.position++, N(e, !0, o))), C = e.line, V(e, o, c, !1, !0), _ = e.tag, m = e.result, N(e, !0, o), O = e.input.charCodeAt(e.position), (x || e.line === C) && O === 58 && (g = !0, O = e.input.charCodeAt(++e.position), N(e, !0, o), V(e, o, c, !1, !0), R = e.result), a ? H(e, E, A, _, m, R) : g ? E.push(H(e, null, A, _, m, R)) : E.push(m), N(e, !0, o), O = e.input.charCodeAt(e.position), O === 44 ? (p = !0, O = e.input.charCodeAt(++e.position)) : p = !1;
    }
    T(e, "unexpected end of the stream within a flow collection");
  }
  function Ce(e, o) {
    var p, C, d = t, E = !1, r = !1, l = o, f = 0, g = !1, x, a;
    if (a = e.input.charCodeAt(e.position), a === 124)
      C = !1;
    else if (a === 62)
      C = !0;
    else
      return !1;
    for (e.kind = "scalar", e.result = ""; a !== 0; )
      if (a = e.input.charCodeAt(++e.position), a === 43 || a === 45)
        t === d ? d = a === 43 ? F : w : T(e, "repeat of a chomping mode identifier");
      else if ((x = pe(a)) >= 0)
        x === 0 ? T(e, "bad explicit indentation width of a block scalar; it cannot be less than one") : r ? T(e, "repeat of an indentation width identifier") : (l = o + x - 1, r = !0);
      else
        break;
    if ($(a)) {
      do
        a = e.input.charCodeAt(++e.position);
      while ($(a));
      if (a === 35)
        do
          a = e.input.charCodeAt(++e.position);
        while (!P(a) && a !== 0);
    }
    for (; a !== 0; ) {
      for (U(e), e.lineIndent = 0, a = e.input.charCodeAt(e.position); (!r || e.lineIndent < l) && a === 32; )
        e.lineIndent++, a = e.input.charCodeAt(++e.position);
      if (!r && e.lineIndent > l && (l = e.lineIndent), P(a)) {
        f++;
        continue;
      }
      if (e.lineIndent < l) {
        d === F ? e.result += u.repeat(`
`, E ? 1 + f : f) : d === t && E && (e.result += `
`);
        break;
      }
      for (C ? $(a) ? (g = !0, e.result += u.repeat(`
`, E ? 1 + f : f)) : g ? (g = !1, e.result += u.repeat(`
`, f + 1)) : f === 0 ? E && (e.result += " ") : e.result += u.repeat(`
`, f) : e.result += u.repeat(`
`, E ? 1 + f : f), E = !0, r = !0, f = 0, p = e.position; !P(a) && a !== 0; )
        a = e.input.charCodeAt(++e.position);
      j(e, p, e.position, !1);
    }
    return !0;
  }
  function z(e, o) {
    var p, C = e.tag, d = e.anchor, E = [], r, l = !1, f;
    for (e.anchor !== null && (e.anchorMap[e.anchor] = E), f = e.input.charCodeAt(e.position); f !== 0 && !(f !== 45 || (r = e.input.charCodeAt(e.position + 1), !B(r))); ) {
      if (l = !0, e.position++, N(e, !0, -1) && e.lineIndent <= o) {
        E.push(null), f = e.input.charCodeAt(e.position);
        continue;
      }
      if (p = e.line, V(e, o, n, !1, !0), E.push(e.result), N(e, !0, -1), f = e.input.charCodeAt(e.position), (e.line === p || e.lineIndent > o) && f !== 0)
        T(e, "bad indentation of a sequence entry");
      else if (e.lineIndent < o)
        break;
    }
    return l ? (e.tag = C, e.anchor = d, e.kind = "sequence", e.result = E, !0) : !1;
  }
  function De(e, o, p) {
    var C, d, E, r, l = e.tag, f = e.anchor, g = {}, x = {}, a = null, A = null, m = null, _ = !1, R = !1, O;
    for (e.anchor !== null && (e.anchorMap[e.anchor] = g), O = e.input.charCodeAt(e.position); O !== 0; ) {
      if (C = e.input.charCodeAt(e.position + 1), E = e.line, r = e.position, (O === 63 || O === 58) && B(C))
        O === 63 ? (_ && (H(e, g, x, a, A, null), a = A = m = null), R = !0, _ = !0, d = !0) : _ ? (_ = !1, d = !0) : T(e, "incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line"), e.position += 1, O = C;
      else if (V(e, p, h, !1, !0))
        if (e.line === E) {
          for (O = e.input.charCodeAt(e.position); $(O); )
            O = e.input.charCodeAt(++e.position);
          if (O === 58)
            O = e.input.charCodeAt(++e.position), B(O) || T(e, "a whitespace character is expected after the key-value separator within a block mapping"), _ && (H(e, g, x, a, A, null), a = A = m = null), R = !0, _ = !1, d = !1, a = e.tag, A = e.result;
          else if (R)
            T(e, "can not read an implicit mapping pair; a colon is missed");
          else
            return e.tag = l, e.anchor = f, !0;
        } else if (R)
          T(e, "can not read a block mapping entry; a multiline key may not be an implicit key");
        else
          return e.tag = l, e.anchor = f, !0;
      else
        break;
      if ((e.line === E || e.lineIndent > o) && (V(e, o, i, !0, d) && (_ ? A = e.result : m = e.result), _ || (H(e, g, x, a, A, m, E, r), a = A = m = null), N(e, !0, -1), O = e.input.charCodeAt(e.position)), e.lineIndent > o && O !== 0)
        T(e, "bad indentation of a mapping entry");
      else if (e.lineIndent < o)
        break;
    }
    return _ && H(e, g, x, a, A, null), R && (e.tag = l, e.anchor = f, e.kind = "mapping", e.result = g), R;
  }
  function Me(e) {
    var o, p = !1, C = !1, d, E, r;
    if (r = e.input.charCodeAt(e.position), r !== 33) return !1;
    if (e.tag !== null && T(e, "duplication of a tag property"), r = e.input.charCodeAt(++e.position), r === 60 ? (p = !0, r = e.input.charCodeAt(++e.position)) : r === 33 ? (C = !0, d = "!!", r = e.input.charCodeAt(++e.position)) : d = "!", o = e.position, p) {
      do
        r = e.input.charCodeAt(++e.position);
      while (r !== 0 && r !== 62);
      e.position < e.length ? (E = e.input.slice(o, e.position), r = e.input.charCodeAt(++e.position)) : T(e, "unexpected end of the stream within a verbatim tag");
    } else {
      for (; r !== 0 && !B(r); )
        r === 33 && (C ? T(e, "tag suffix cannot contain exclamation marks") : (d = e.input.slice(o - 1, e.position + 1), G.test(d) || T(e, "named tag handle cannot contain such characters"), C = !0, o = e.position + 1)), r = e.input.charCodeAt(++e.position);
      E = e.input.slice(o, e.position), L.test(E) && T(e, "tag suffix cannot contain flow indicator characters");
    }
    return E && !J.test(E) && T(e, "tag name cannot contain such characters: " + E), p ? e.tag = E : s.call(e.tagMap, d) ? e.tag = e.tagMap[d] + E : d === "!" ? e.tag = "!" + E : d === "!!" ? e.tag = "tag:yaml.org,2002:" + E : T(e, 'undeclared tag handle "' + d + '"'), !0;
  }
  function Ee(e) {
    var o, p;
    if (p = e.input.charCodeAt(e.position), p !== 38) return !1;
    for (e.anchor !== null && T(e, "duplication of an anchor property"), p = e.input.charCodeAt(++e.position), o = e.position; p !== 0 && !B(p) && !Q(p); )
      p = e.input.charCodeAt(++e.position);
    return e.position === o && T(e, "name of an anchor node must contain at least one character"), e.anchor = e.input.slice(o, e.position), !0;
  }
  function we(e) {
    var o, p, C;
    if (C = e.input.charCodeAt(e.position), C !== 42) return !1;
    for (C = e.input.charCodeAt(++e.position), o = e.position; C !== 0 && !B(C) && !Q(C); )
      C = e.input.charCodeAt(++e.position);
    return e.position === o && T(e, "name of an alias node must contain at least one character"), p = e.input.slice(o, e.position), s.call(e.anchorMap, p) || T(e, 'unidentified alias "' + p + '"'), e.result = e.anchorMap[p], N(e, !0, -1), !0;
  }
  function V(e, o, p, C, d) {
    var E, r, l, f = 1, g = !1, x = !1, a, A, m, _, R;
    if (e.listener !== null && e.listener("open", e), e.tag = null, e.anchor = null, e.kind = null, e.result = null, E = r = l = i === p || n === p, C && N(e, !0, -1) && (g = !0, e.lineIndent > o ? f = 1 : e.lineIndent === o ? f = 0 : e.lineIndent < o && (f = -1)), f === 1)
      for (; Me(e) || Ee(e); )
        N(e, !0, -1) ? (g = !0, l = E, e.lineIndent > o ? f = 1 : e.lineIndent === o ? f = 0 : e.lineIndent < o && (f = -1)) : l = !1;
    if (l && (l = g || d), (f === 1 || i === p) && (c === p || h === p ? _ = o : _ = o + 1, R = e.position - e.lineStart, f === 1 ? l && (z(e, R) || De(e, R, _)) || ye(e, _) ? x = !0 : (r && Ce(e, _) || ge(e, _) || Ae(e, _) ? x = !0 : we(e) ? (x = !0, (e.tag !== null || e.anchor !== null) && T(e, "alias node should not have any properties")) : ve(e, _, c === p) && (x = !0, e.tag === null && (e.tag = "?")), e.anchor !== null && (e.anchorMap[e.anchor] = e.result)) : f === 0 && (x = l && z(e, R))), e.tag !== null && e.tag !== "!")
      if (e.tag === "?") {
        for (e.result !== null && e.kind !== "scalar" && T(e, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + e.kind + '"'), a = 0, A = e.implicitTypes.length; a < A; a += 1)
          if (m = e.implicitTypes[a], m.resolve(e.result)) {
            e.result = m.construct(e.result), e.tag = m.tag, e.anchor !== null && (e.anchorMap[e.anchor] = e.result);
            break;
          }
      } else s.call(e.typeMap[e.kind || "fallback"], e.tag) ? (m = e.typeMap[e.kind || "fallback"][e.tag], e.result !== null && m.kind !== e.kind && T(e, "unacceptable node kind for !<" + e.tag + '> tag; it should be "' + m.kind + '", not "' + e.kind + '"'), m.resolve(e.result) ? (e.result = m.construct(e.result), e.anchor !== null && (e.anchorMap[e.anchor] = e.result)) : T(e, "cannot resolve a node with !<" + e.tag + "> explicit tag")) : T(e, "unknown tag !<" + e.tag + ">");
    return e.listener !== null && e.listener("close", e), e.tag !== null || e.anchor !== null || x;
  }
  function Fe(e) {
    var o = e.position, p, C, d, E = !1, r;
    for (e.version = null, e.checkLineBreaks = e.legacy, e.tagMap = {}, e.anchorMap = {}; (r = e.input.charCodeAt(e.position)) !== 0 && (N(e, !0, -1), r = e.input.charCodeAt(e.position), !(e.lineIndent > 0 || r !== 37)); ) {
      for (E = !0, r = e.input.charCodeAt(++e.position), p = e.position; r !== 0 && !B(r); )
        r = e.input.charCodeAt(++e.position);
      for (C = e.input.slice(p, e.position), d = [], C.length < 1 && T(e, "directive name must not be less than one character in length"); r !== 0; ) {
        for (; $(r); )
          r = e.input.charCodeAt(++e.position);
        if (r === 35) {
          do
            r = e.input.charCodeAt(++e.position);
          while (r !== 0 && !P(r));
          break;
        }
        if (P(r)) break;
        for (p = e.position; r !== 0 && !B(r); )
          r = e.input.charCodeAt(++e.position);
        d.push(e.input.slice(p, e.position));
      }
      r !== 0 && U(e), s.call(le, C) ? le[C](e, C, d) : ee(e, 'unknown document directive "' + C + '"');
    }
    if (N(e, !0, -1), e.lineIndent === 0 && e.input.charCodeAt(e.position) === 45 && e.input.charCodeAt(e.position + 1) === 45 && e.input.charCodeAt(e.position + 2) === 45 ? (e.position += 3, N(e, !0, -1)) : E && T(e, "directives end mark is expected"), V(e, e.lineIndent - 1, i, !1, !0), N(e, !0, -1), e.checkLineBreaks && k.test(e.input.slice(o, e.position)) && ee(e, "non-ASCII line breaks are interpreted as content"), e.documents.push(e.result), e.position === e.lineStart && Z(e)) {
      e.input.charCodeAt(e.position) === 46 && (e.position += 3, N(e, !0, -1));
      return;
    }
    if (e.position < e.length - 1)
      T(e, "end of the stream or a document separator is expected");
    else
      return;
  }
  function _e(e, o) {
    e = String(e), o = o || {}, e.length !== 0 && (e.charCodeAt(e.length - 1) !== 10 && e.charCodeAt(e.length - 1) !== 13 && (e += `
`), e.charCodeAt(0) === 65279 && (e = e.slice(1)));
    var p = new Le(e, o), C = e.indexOf("\0");
    for (C !== -1 && (p.position = C, T(p, "null byte is not allowed in input")), p.input += "\0"; p.input.charCodeAt(p.position) === 32; )
      p.lineIndent += 1, p.position += 1;
    for (; p.position < p.length - 1; )
      Fe(p);
    return p.documents;
  }
  function Se(e, o, p) {
    o !== null && typeof o == "object" && typeof p > "u" && (p = o, o = null);
    var C = _e(e, p);
    if (typeof o != "function")
      return C;
    for (var d = 0, E = C.length; d < E; d += 1)
      o(C[d]);
  }
  function be(e, o) {
    var p = _e(e, o);
    if (p.length !== 0) {
      if (p.length === 1)
        return p[0];
      throw new y("expected a single document in the stream, but found more");
    }
  }
  function Ne(e, o, p) {
    return typeof o == "object" && o !== null && typeof p > "u" && (p = o, o = null), Se(e, o, u.extend({ schema: b }, p));
  }
  function qe(e, o) {
    return be(e, u.extend({ schema: b }, o));
  }
  return re.loadAll = Se, re.load = be, re.safeLoadAll = Ne, re.safeLoad = qe, re;
}
var Oe = {}, Yr;
function xn() {
  if (Yr) return Oe;
  Yr = 1;
  var u = ne(), y = ce(), S = Re(), b = fe(), v = Object.prototype.toString, s = Object.prototype.hasOwnProperty, c = 9, h = 10, n = 13, i = 32, t = 33, w = 34, F = 35, I = 37, k = 38, L = 39, G = 42, J = 44, W = 45, P = 58, $ = 61, B = 62, Q = 63, Ie = 64, ae = 91, pe = 93, se = 96, he = 123, de = 124, oe = 125, D = {};
  D[0] = "\\0", D[7] = "\\a", D[8] = "\\b", D[9] = "\\t", D[10] = "\\n", D[11] = "\\v", D[12] = "\\f", D[13] = "\\r", D[27] = "\\e", D[34] = '\\"', D[92] = "\\\\", D[133] = "\\N", D[160] = "\\_", D[8232] = "\\L", D[8233] = "\\P";
  var Le = [
    "y",
    "Y",
    "yes",
    "Yes",
    "YES",
    "on",
    "On",
    "ON",
    "n",
    "N",
    "no",
    "No",
    "NO",
    "off",
    "Off",
    "OFF"
  ];
  function me(r, l) {
    var f, g, x, a, A, m, _;
    if (l === null) return {};
    for (f = {}, g = Object.keys(l), x = 0, a = g.length; x < a; x += 1)
      A = g[x], m = String(l[A]), A.slice(0, 2) === "!!" && (A = "tag:yaml.org,2002:" + A.slice(2)), _ = r.compiledTypeMap.fallback[A], _ && s.call(_.styleAliases, m) && (m = _.styleAliases[m]), f[A] = m;
    return f;
  }
  function T(r) {
    var l, f, g;
    if (l = r.toString(16).toUpperCase(), r <= 255)
      f = "x", g = 2;
    else if (r <= 65535)
      f = "u", g = 4;
    else if (r <= 4294967295)
      f = "U", g = 8;
    else
      throw new y("code point within a string may not be greater than 0xFFFFFFFF");
    return "\\" + f + u.repeat("0", g - l.length) + l;
  }
  function ee(r) {
    this.schema = r.schema || S, this.indent = Math.max(1, r.indent || 2), this.noArrayIndent = r.noArrayIndent || !1, this.skipInvalid = r.skipInvalid || !1, this.flowLevel = u.isNothing(r.flowLevel) ? -1 : r.flowLevel, this.styleMap = me(this.schema, r.styles || null), this.sortKeys = r.sortKeys || !1, this.lineWidth = r.lineWidth || 80, this.noRefs = r.noRefs || !1, this.noCompatMode = r.noCompatMode || !1, this.condenseFlow = r.condenseFlow || !1, this.implicitTypes = this.schema.compiledImplicit, this.explicitTypes = this.schema.compiledExplicit, this.tag = null, this.result = "", this.duplicates = [], this.usedDuplicates = null;
  }
  function le(r, l) {
    for (var f = u.repeat(" ", l), g = 0, x = -1, a = "", A, m = r.length; g < m; )
      x = r.indexOf(`
`, g), x === -1 ? (A = r.slice(g), g = m) : (A = r.slice(g, x + 1), g = x + 1), A.length && A !== `
` && (a += f), a += A;
    return a;
  }
  function j(r, l) {
    return `
` + u.repeat(" ", r.indent * l);
  }
  function xe(r, l) {
    var f, g, x;
    for (f = 0, g = r.implicitTypes.length; f < g; f += 1)
      if (x = r.implicitTypes[f], x.resolve(l))
        return !0;
    return !1;
  }
  function H(r) {
    return r === i || r === c;
  }
  function U(r) {
    return 32 <= r && r <= 126 || 161 <= r && r <= 55295 && r !== 8232 && r !== 8233 || 57344 <= r && r <= 65533 && r !== 65279 || 65536 <= r && r <= 1114111;
  }
  function N(r) {
    return U(r) && !H(r) && r !== 65279 && r !== n && r !== h;
  }
  function Z(r, l) {
    return U(r) && r !== 65279 && r !== J && r !== ae && r !== pe && r !== he && r !== oe && r !== P && (r !== F || l && N(l));
  }
  function ue(r) {
    return U(r) && r !== 65279 && !H(r) && r !== W && r !== Q && r !== P && r !== J && r !== ae && r !== pe && r !== he && r !== oe && r !== F && r !== k && r !== G && r !== t && r !== de && r !== $ && r !== B && r !== L && r !== w && r !== I && r !== Ie && r !== se;
  }
  function ve(r) {
    var l = /^\n* /;
    return l.test(r);
  }
  var ge = 1, Ae = 2, ye = 3, Ce = 4, z = 5;
  function De(r, l, f, g, x) {
    var a, A, m, _ = !1, R = !1, O = g !== -1, K = -1, Y = ue(r.charCodeAt(0)) && !H(r.charCodeAt(r.length - 1));
    if (l)
      for (a = 0; a < r.length; a++) {
        if (A = r.charCodeAt(a), !U(A))
          return z;
        m = a > 0 ? r.charCodeAt(a - 1) : null, Y = Y && Z(A, m);
      }
    else {
      for (a = 0; a < r.length; a++) {
        if (A = r.charCodeAt(a), A === h)
          _ = !0, O && (R = R || // Foldable line = too long, and not more-indented.
          a - K - 1 > g && r[K + 1] !== " ", K = a);
        else if (!U(A))
          return z;
        m = a > 0 ? r.charCodeAt(a - 1) : null, Y = Y && Z(A, m);
      }
      R = R || O && a - K - 1 > g && r[K + 1] !== " ";
    }
    return !_ && !R ? Y && !x(r) ? ge : Ae : f > 9 && ve(r) ? z : R ? Ce : ye;
  }
  function Me(r, l, f, g) {
    r.dump = (function() {
      if (l.length === 0)
        return "''";
      if (!r.noCompatMode && Le.indexOf(l) !== -1)
        return "'" + l + "'";
      var x = r.indent * Math.max(1, f), a = r.lineWidth === -1 ? -1 : Math.max(Math.min(r.lineWidth, 40), r.lineWidth - x), A = g || r.flowLevel > -1 && f >= r.flowLevel;
      function m(_) {
        return xe(r, _);
      }
      switch (De(l, A, r.indent, a, m)) {
        case ge:
          return l;
        case Ae:
          return "'" + l.replace(/'/g, "''") + "'";
        case ye:
          return "|" + Ee(l, r.indent) + we(le(l, x));
        case Ce:
          return ">" + Ee(l, r.indent) + we(le(V(l, a), x));
        case z:
          return '"' + _e(l) + '"';
        default:
          throw new y("impossible error: invalid scalar style");
      }
    })();
  }
  function Ee(r, l) {
    var f = ve(r) ? String(l) : "", g = r[r.length - 1] === `
`, x = g && (r[r.length - 2] === `
` || r === `
`), a = x ? "+" : g ? "" : "-";
    return f + a + `
`;
  }
  function we(r) {
    return r[r.length - 1] === `
` ? r.slice(0, -1) : r;
  }
  function V(r, l) {
    for (var f = /(\n+)([^\n]*)/g, g = (function() {
      var R = r.indexOf(`
`);
      return R = R !== -1 ? R : r.length, f.lastIndex = R, Fe(r.slice(0, R), l);
    })(), x = r[0] === `
` || r[0] === " ", a, A; A = f.exec(r); ) {
      var m = A[1], _ = A[2];
      a = _[0] === " ", g += m + (!x && !a && _ !== "" ? `
` : "") + Fe(_, l), x = a;
    }
    return g;
  }
  function Fe(r, l) {
    if (r === "" || r[0] === " ") return r;
    for (var f = / [^ ]/g, g, x = 0, a, A = 0, m = 0, _ = ""; g = f.exec(r); )
      m = g.index, m - x > l && (a = A > x ? A : m, _ += `
` + r.slice(x, a), x = a + 1), A = m;
    return _ += `
`, r.length - x > l && A > x ? _ += r.slice(x, A) + `
` + r.slice(A + 1) : _ += r.slice(x), _.slice(1);
  }
  function _e(r) {
    for (var l = "", f, g, x, a = 0; a < r.length; a++) {
      if (f = r.charCodeAt(a), f >= 55296 && f <= 56319 && (g = r.charCodeAt(a + 1), g >= 56320 && g <= 57343)) {
        l += T((f - 55296) * 1024 + g - 56320 + 65536), a++;
        continue;
      }
      x = D[f], l += !x && U(f) ? r[a] : x || T(f);
    }
    return l;
  }
  function Se(r, l, f) {
    var g = "", x = r.tag, a, A;
    for (a = 0, A = f.length; a < A; a += 1)
      o(r, l, f[a], !1, !1) && (a !== 0 && (g += "," + (r.condenseFlow ? "" : " ")), g += r.dump);
    r.tag = x, r.dump = "[" + g + "]";
  }
  function be(r, l, f, g) {
    var x = "", a = r.tag, A, m;
    for (A = 0, m = f.length; A < m; A += 1)
      o(r, l + 1, f[A], !0, !0) && ((!g || A !== 0) && (x += j(r, l)), r.dump && h === r.dump.charCodeAt(0) ? x += "-" : x += "- ", x += r.dump);
    r.tag = a, r.dump = x || "[]";
  }
  function Ne(r, l, f) {
    var g = "", x = r.tag, a = Object.keys(f), A, m, _, R, O;
    for (A = 0, m = a.length; A < m; A += 1)
      O = "", A !== 0 && (O += ", "), r.condenseFlow && (O += '"'), _ = a[A], R = f[_], o(r, l, _, !1, !1) && (r.dump.length > 1024 && (O += "? "), O += r.dump + (r.condenseFlow ? '"' : "") + ":" + (r.condenseFlow ? "" : " "), o(r, l, R, !1, !1) && (O += r.dump, g += O));
    r.tag = x, r.dump = "{" + g + "}";
  }
  function qe(r, l, f, g) {
    var x = "", a = r.tag, A = Object.keys(f), m, _, R, O, K, Y;
    if (r.sortKeys === !0)
      A.sort();
    else if (typeof r.sortKeys == "function")
      A.sort(r.sortKeys);
    else if (r.sortKeys)
      throw new y("sortKeys must be a boolean or a function");
    for (m = 0, _ = A.length; m < _; m += 1)
      Y = "", (!g || m !== 0) && (Y += j(r, l)), R = A[m], O = f[R], o(r, l + 1, R, !0, !0, !0) && (K = r.tag !== null && r.tag !== "?" || r.dump && r.dump.length > 1024, K && (r.dump && h === r.dump.charCodeAt(0) ? Y += "?" : Y += "? "), Y += r.dump, K && (Y += j(r, l)), o(r, l + 1, O, !0, K) && (r.dump && h === r.dump.charCodeAt(0) ? Y += ":" : Y += ": ", Y += r.dump, x += Y));
    r.tag = a, r.dump = x || "{}";
  }
  function e(r, l, f) {
    var g, x, a, A, m, _;
    for (x = f ? r.explicitTypes : r.implicitTypes, a = 0, A = x.length; a < A; a += 1)
      if (m = x[a], (m.instanceOf || m.predicate) && (!m.instanceOf || typeof l == "object" && l instanceof m.instanceOf) && (!m.predicate || m.predicate(l))) {
        if (r.tag = f ? m.tag : "?", m.represent) {
          if (_ = r.styleMap[m.tag] || m.defaultStyle, v.call(m.represent) === "[object Function]")
            g = m.represent(l, _);
          else if (s.call(m.represent, _))
            g = m.represent[_](l, _);
          else
            throw new y("!<" + m.tag + '> tag resolver accepts not "' + _ + '" style');
          r.dump = g;
        }
        return !0;
      }
    return !1;
  }
  function o(r, l, f, g, x, a) {
    r.tag = null, r.dump = f, e(r, f, !1) || e(r, f, !0);
    var A = v.call(r.dump);
    g && (g = r.flowLevel < 0 || r.flowLevel > l);
    var m = A === "[object Object]" || A === "[object Array]", _, R;
    if (m && (_ = r.duplicates.indexOf(f), R = _ !== -1), (r.tag !== null && r.tag !== "?" || R || r.indent !== 2 && l > 0) && (x = !1), R && r.usedDuplicates[_])
      r.dump = "*ref_" + _;
    else {
      if (m && R && !r.usedDuplicates[_] && (r.usedDuplicates[_] = !0), A === "[object Object]")
        g && Object.keys(r.dump).length !== 0 ? (qe(r, l, r.dump, x), R && (r.dump = "&ref_" + _ + r.dump)) : (Ne(r, l, r.dump), R && (r.dump = "&ref_" + _ + " " + r.dump));
      else if (A === "[object Array]") {
        var O = r.noArrayIndent && l > 0 ? l - 1 : l;
        g && r.dump.length !== 0 ? (be(r, O, r.dump, x), R && (r.dump = "&ref_" + _ + r.dump)) : (Se(r, O, r.dump), R && (r.dump = "&ref_" + _ + " " + r.dump));
      } else if (A === "[object String]")
        r.tag !== "?" && Me(r, r.dump, l, a);
      else {
        if (r.skipInvalid) return !1;
        throw new y("unacceptable kind of an object to dump " + A);
      }
      r.tag !== null && r.tag !== "?" && (r.dump = "!<" + r.tag + "> " + r.dump);
    }
    return !0;
  }
  function p(r, l) {
    var f = [], g = [], x, a;
    for (C(r, f, g), x = 0, a = g.length; x < a; x += 1)
      l.duplicates.push(f[g[x]]);
    l.usedDuplicates = new Array(a);
  }
  function C(r, l, f) {
    var g, x, a;
    if (r !== null && typeof r == "object")
      if (x = l.indexOf(r), x !== -1)
        f.indexOf(x) === -1 && f.push(x);
      else if (l.push(r), Array.isArray(r))
        for (x = 0, a = r.length; x < a; x += 1)
          C(r[x], l, f);
      else
        for (g = Object.keys(r), x = 0, a = g.length; x < a; x += 1)
          C(r[g[x]], l, f);
  }
  function d(r, l) {
    l = l || {};
    var f = new ee(l);
    return f.noRefs || p(r, f), o(f, 0, r, !0, !0) ? f.dump + `
` : "";
  }
  function E(r, l) {
    return d(r, u.extend({ schema: b }, l));
  }
  return Oe.dump = d, Oe.safeDump = E, Oe;
}
var Pr;
function vn() {
  if (Pr) return M;
  Pr = 1;
  var u = mn(), y = xn();
  function S(b) {
    return function() {
      throw new Error("Function " + b + " is deprecated and cannot be used.");
    };
  }
  return M.Type = q(), M.Schema = ie(), M.FAILSAFE_SCHEMA = pr(), M.JSON_SCHEMA = Gr(), M.CORE_SCHEMA = Wr(), M.DEFAULT_SAFE_SCHEMA = fe(), M.DEFAULT_FULL_SCHEMA = Re(), M.load = u.load, M.loadAll = u.loadAll, M.safeLoad = u.safeLoad, M.safeLoadAll = u.safeLoadAll, M.dump = y.dump, M.safeDump = y.safeDump, M.YAMLException = ce(), M.MINIMAL_SCHEMA = pr(), M.SAFE_SCHEMA = fe(), M.DEFAULT_SCHEMA = Re(), M.scan = S("scan"), M.parse = S("parse"), M.compose = S("compose"), M.addConstructor = S("addConstructor"), M;
}
var cr, jr;
function gn() {
  if (jr) return cr;
  jr = 1;
  var u = vn();
  return cr = u, cr;
}
var Hr;
function An() {
  if (Hr) return Te.exports;
  Hr = 1;
  var u = gn(), y = "\\ufeff?", S = typeof process < "u" ? process.platform : "", b = "^(" + y + "(= yaml =|---)$([\\s\\S]*?)^(?:\\2|\\.\\.\\.)\\s*$" + (S === "win32" ? "\\r?" : "") + "(?:\\n)?)", v = new RegExp(b, "m");
  Te.exports = s, Te.exports.test = n;
  function s(i, t) {
    i = i || "";
    var w = { allowUnsafe: !1 };
    t = t instanceof Object ? { ...w, ...t } : w, t.allowUnsafe = !!t.allowUnsafe;
    var F = i.split(/(\r?\n)/);
    return F[0] && /= yaml =|---/.test(F[0]) ? h(i, t.allowUnsafe) : {
      attributes: {},
      body: i,
      bodyBegin: 1
    };
  }
  function c(i, t) {
    for (var w = 1, F = t.indexOf(`
`), I = i.index + i[0].length; F !== -1; ) {
      if (F >= I)
        return w;
      w++, F = t.indexOf(`
`, F + 1);
    }
    return w;
  }
  function h(i, t) {
    var w = v.exec(i);
    if (!w)
      return {
        attributes: {},
        body: i,
        bodyBegin: 1
      };
    var F = t ? u.load : u.safeLoad, I = w[w.length - 1].replace(/^\s+|\s+$/g, ""), k = F(I) || {}, L = i.replace(w[0], ""), G = c(w, i);
    return {
      attributes: k,
      body: L,
      bodyBegin: G,
      frontmatter: I
    };
  }
  function n(i) {
    return i = i || "", v.test(i);
  }
  return Te.exports;
}
var yn = An();
const Cn = /* @__PURE__ */ Vr(yn), ar = ".md", En = "_";
function Ur(u) {
  return (u.charAt(0).toUpperCase() + u.slice(1)).replaceAll("-", " ");
}
function Jr(u) {
  try {
    return te.accessSync(u, te.constants.R_OK), !0;
  } catch {
    return !1;
  }
}
function Kr(u) {
  try {
    return te.statSync(u);
  } catch (y) {
    return console.warn(`[vitepress-plugin-auto-sidebar] Cannot read stats for: ${u}`, y), null;
  }
}
function wn(u) {
  try {
    const y = te.readFileSync(u, { encoding: "utf-8" });
    return Cn(y).attributes?.title;
  } catch (y) {
    console.warn(
      `[vitepress-plugin-auto-sidebar] Cannot read frontmatter from: ${u}`,
      y
    );
    return;
  }
}
function Qr(u, y, S, b) {
  return u.filter((v) => {
    const s = typeof v == "string" ? v : v.path, c = ke.resolve(y, s);
    if (!Jr(c))
      return !1;
    const h = Kr(c);
    return h && (s.endsWith(ar) || h.isDirectory());
  }).map((v) => {
    const s = typeof v == "string" ? v : v.path, c = ke.resolve(y, s), h = Kr(c);
    if (!h)
      return null;
    if (h.isDirectory())
      try {
        const n = Qr(te.readdirSync(c), c, S, b);
        if (n.length === 0)
          return null;
        const i = s.split("/").pop() ?? "";
        return {
          text: typeof v != "string" && v.title ? v.title : Ur(i),
          collapsible: b.collapsible,
          collapsed: b.collapsed,
          items: n
        };
      } catch (n) {
        return console.warn(`[vitepress-plugin-auto-sidebar] Cannot read directory: ${c}`, n), null;
      }
    else if (s.endsWith(ar) && !s.startsWith(En)) {
      let n;
      b.useFrontmatter && (n = wn(c));
      const i = Ur(s.slice(0, -ar.length));
      return {
        text: n || i,
        link: c.replace(S, "")
      };
    }
    return null;
  }).filter((v) => v !== null);
}
function Sn(u = {}) {
  const y = {
    contentRoot: u.contentRoot ?? "/",
    contentDirs: u.contentDirs?.length ? u.contentDirs : ["/"],
    collapsible: u.collapsible ?? !0,
    collapsed: u.collapsed ?? !0,
    useFrontmatter: u.useFrontmatter ?? !1
  }, S = ke.isAbsolute(y.contentRoot) ? y.contentRoot : ke.join(process.cwd(), y.contentRoot);
  return Jr(S) ? Qr(y.contentDirs, S, S, y) : (console.error(`[vitepress-plugin-auto-sidebar] Content root does not exist: ${S}`), []);
}
export {
  Sn as getSidebar
};
